{"ast":null,"code":"/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g;\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n/**\n * @type {(\n *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n * )}\n */\n\n/**\n * @param {string} [selector]\n * @param {string} [defaultTagName='div']\n * @returns {Element}\n */\nfunction (selector) {\n  let defaultTagName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'div';\n  var value = selector || '';\n  /** @type {Properties} */\n  var props = {};\n  var start = 0;\n  /** @type {string} */\n  var subvalue;\n  /** @type {string} */\n  var previous;\n  /** @type {RegExpMatchArray} */\n  var match;\n  while (start < value.length) {\n    search.lastIndex = start;\n    match = search.exec(value);\n    subvalue = value.slice(start, match ? match.index : value.length);\n    if (subvalue) {\n      if (!previous) {\n        defaultTagName = subvalue;\n      } else if (previous === '#') {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n      start += subvalue.length;\n    }\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n  return {\n    type: 'element',\n    tagName: defaultTagName,\n    properties: props,\n    children: []\n  };\n};","map":{"version":3,"names":["search","parseSelector","selector","defaultTagName","arguments","length","undefined","value","props","start","subvalue","previous","match","lastIndex","exec","slice","index","id","Array","isArray","className","push","type","tagName","properties","children"],"sources":["/Users/philippknestel/Documents/GitHub/portfolio/portfolio-phkn/node_modules/hast-util-parse-selector/index.js"],"sourcesContent":["/**\n * @typedef {import('hast').Properties} Properties\n * @typedef {import('hast').Element} Element\n */\n\nvar search = /[#.]/g\n\n/**\n * Create a hast element from a simple CSS selector.\n *\n * @param selector A simple CSS selector.\n *   Can contain a tag-name (`foo`), classes (`.bar`), and an ID (`#baz`).\n *   Multiple classes are allowed.\n *   Uses the last ID if multiple IDs are found.\n * @param [defaultTagName='div'] Tag name to use if `selector` does not specify one.\n */\nexport const parseSelector =\n  /**\n   * @type {(\n   *  <Selector extends string, DefaultTagName extends string = 'div'>(selector?: Selector, defaultTagName?: DefaultTagName) => Element & {tagName: import('./extract.js').ExtractTagName<Selector, DefaultTagName>}\n   * )}\n   */\n  (\n    /**\n     * @param {string} [selector]\n     * @param {string} [defaultTagName='div']\n     * @returns {Element}\n     */\n    function (selector, defaultTagName = 'div') {\n      var value = selector || ''\n      /** @type {Properties} */\n      var props = {}\n      var start = 0\n      /** @type {string} */\n      var subvalue\n      /** @type {string} */\n      var previous\n      /** @type {RegExpMatchArray} */\n      var match\n\n      while (start < value.length) {\n        search.lastIndex = start\n        match = search.exec(value)\n        subvalue = value.slice(start, match ? match.index : value.length)\n\n        if (subvalue) {\n          if (!previous) {\n            defaultTagName = subvalue\n          } else if (previous === '#') {\n            props.id = subvalue\n          } else if (Array.isArray(props.className)) {\n            props.className.push(subvalue)\n          } else {\n            props.className = [subvalue]\n          }\n\n          start += subvalue.length\n        }\n\n        if (match) {\n          previous = match[0]\n          start++\n        }\n      }\n\n      return {\n        type: 'element',\n        tagName: defaultTagName,\n        properties: props,\n        children: []\n      }\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAG,OAAO;;AAEpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,aAAa;AACxB;AACF;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACI,SAAAA,CAAUC,QAAQ,EAA0B;EAAA,IAAxBC,cAAc,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACxC,IAAIG,KAAK,GAAGL,QAAQ,IAAI,EAAE;EAC1B;EACA,IAAIM,KAAK,GAAG,CAAC,CAAC;EACd,IAAIC,KAAK,GAAG,CAAC;EACb;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,QAAQ;EACZ;EACA,IAAIC,KAAK;EAET,OAAOH,KAAK,GAAGF,KAAK,CAACF,MAAM,EAAE;IAC3BL,MAAM,CAACa,SAAS,GAAGJ,KAAK;IACxBG,KAAK,GAAGZ,MAAM,CAACc,IAAI,CAACP,KAAK,CAAC;IAC1BG,QAAQ,GAAGH,KAAK,CAACQ,KAAK,CAACN,KAAK,EAAEG,KAAK,GAAGA,KAAK,CAACI,KAAK,GAAGT,KAAK,CAACF,MAAM,CAAC;IAEjE,IAAIK,QAAQ,EAAE;MACZ,IAAI,CAACC,QAAQ,EAAE;QACbR,cAAc,GAAGO,QAAQ;MAC3B,CAAC,MAAM,IAAIC,QAAQ,KAAK,GAAG,EAAE;QAC3BH,KAAK,CAACS,EAAE,GAAGP,QAAQ;MACrB,CAAC,MAAM,IAAIQ,KAAK,CAACC,OAAO,CAACX,KAAK,CAACY,SAAS,CAAC,EAAE;QACzCZ,KAAK,CAACY,SAAS,CAACC,IAAI,CAACX,QAAQ,CAAC;MAChC,CAAC,MAAM;QACLF,KAAK,CAACY,SAAS,GAAG,CAACV,QAAQ,CAAC;MAC9B;MAEAD,KAAK,IAAIC,QAAQ,CAACL,MAAM;IAC1B;IAEA,IAAIO,KAAK,EAAE;MACTD,QAAQ,GAAGC,KAAK,CAAC,CAAC,CAAC;MACnBH,KAAK,EAAE;IACT;EACF;EAEA,OAAO;IACLa,IAAI,EAAE,SAAS;IACfC,OAAO,EAAEpB,cAAc;IACvBqB,UAAU,EAAEhB,KAAK;IACjBiB,QAAQ,EAAE;EACZ,CAAC;AACH,CACD","ignoreList":[]},"metadata":{},"sourceType":"module"}