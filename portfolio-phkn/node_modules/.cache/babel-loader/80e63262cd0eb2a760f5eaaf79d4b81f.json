{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport { splice } from 'micromark-util-chunked';\nimport { classifyCharacter } from 'micromark-util-classify-character';\nimport { resolveAll } from 'micromark-util-resolve-all';\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfmStrikethrough() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let single = options.singleTilde;\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === undefined) {\n    single = true;\n  }\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  };\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1; // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (events[index][0] === 'enter' && events[index][1].type === 'strikethroughSequenceTemporary' && events[index][1]._close) {\n        let open = index; // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (events[open][0] === 'exit' && events[open][1].type === 'strikethroughSequenceTemporary' && events[open][1]._open &&\n          // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = 'strikethroughSequence';\n            events[open][1].type = 'strikethroughSequence';\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            }; // Opening.\n\n            const nextEvents = [['enter', strikethrough, context], ['enter', events[open][1], context], ['exit', events[open][1], context], ['enter', text, context]]; // Between.\n\n            splice(nextEvents, nextEvents.length, 0, resolveAll(context.parser.constructs.insideSpan.null, events.slice(open + 1, index), context)); // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [['exit', text, context], ['enter', events[index][1], context], ['exit', events[index][1], context], ['exit', strikethrough, context]]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data';\n      }\n    }\n    return events;\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      if (previous === 126 && events[events.length - 1][1].type !== 'characterEscape') {\n        return nok(code);\n      }\n      effects.enter('strikethroughSequenceTemporary');\n      return more(code);\n    }\n    /** @type {State} */\n\n    function more(code) {\n      const before = classifyCharacter(previous);\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code);\n        effects.consume(code);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code);\n      const token = effects.exit('strikethroughSequenceTemporary');\n      const after = classifyCharacter(code);\n      token._open = !after || after === 2 && Boolean(before);\n      token._close = !before || before === 2 && Boolean(after);\n      return ok(code);\n    }\n  }\n}","map":{"version":3,"names":["splice","classifyCharacter","resolveAll","gfmStrikethrough","options","arguments","length","undefined","single","singleTilde","tokenizer","tokenize","tokenizeStrikethrough","resolveAllStrikethrough","text","insideSpan","null","attentionMarkers","events","context","index","type","_close","open","_open","end","offset","start","strikethrough","Object","assign","nextEvents","parser","constructs","slice","effects","ok","nok","previous","size","code","enter","more","before","consume","token","exit","after","Boolean"],"sources":["/Users/philippknestel/Documents/GitHub/portfolio/portfolio-phkn/node_modules/micromark-extension-gfm-strikethrough/lib/syntax.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Event} Event\n */\n\n/**\n * @typedef Options\n *   Configuration (optional).\n * @property {boolean} [singleTilde=true]\n *   Whether to support strikethrough with a single tilde (`boolean`, default:\n *   `true`).\n *   Single tildes work on github.com, but are technically prohibited by the\n *   GFM spec.\n */\nimport {splice} from 'micromark-util-chunked'\nimport {classifyCharacter} from 'micromark-util-classify-character'\nimport {resolveAll} from 'micromark-util-resolve-all'\n\n/**\n * @param {Options} [options]\n * @returns {Extension}\n */\nexport function gfmStrikethrough(options = {}) {\n  let single = options.singleTilde\n  const tokenizer = {\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  }\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    text: {\n      [126]: tokenizer\n    },\n    insideSpan: {\n      null: [tokenizer]\n    },\n    attentionMarkers: {\n      null: [126]\n    }\n  }\n  /**\n   * Take events and resolve strikethrough.\n   *\n   * @type {Resolver}\n   */\n\n  function resolveAllStrikethrough(events, context) {\n    let index = -1 // Walk through all events.\n\n    while (++index < events.length) {\n      // Find a token that can close.\n      if (\n        events[index][0] === 'enter' &&\n        events[index][1].type === 'strikethroughSequenceTemporary' &&\n        events[index][1]._close\n      ) {\n        let open = index // Now walk back to find an opener.\n\n        while (open--) {\n          // Find a token that can open the closer.\n          if (\n            events[open][0] === 'exit' &&\n            events[open][1].type === 'strikethroughSequenceTemporary' &&\n            events[open][1]._open && // If the sizes are the same:\n            events[index][1].end.offset - events[index][1].start.offset ===\n              events[open][1].end.offset - events[open][1].start.offset\n          ) {\n            events[index][1].type = 'strikethroughSequence'\n            events[open][1].type = 'strikethroughSequence'\n            const strikethrough = {\n              type: 'strikethrough',\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            }\n            const text = {\n              type: 'strikethroughText',\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            } // Opening.\n\n            const nextEvents = [\n              ['enter', strikethrough, context],\n              ['enter', events[open][1], context],\n              ['exit', events[open][1], context],\n              ['enter', text, context]\n            ] // Between.\n\n            splice(\n              nextEvents,\n              nextEvents.length,\n              0,\n              resolveAll(\n                context.parser.constructs.insideSpan.null,\n                events.slice(open + 1, index),\n                context\n              )\n            ) // Closing.\n\n            splice(nextEvents, nextEvents.length, 0, [\n              ['exit', text, context],\n              ['enter', events[index][1], context],\n              ['exit', events[index][1], context],\n              ['exit', strikethrough, context]\n            ])\n            splice(events, open - 1, index - open + 3, nextEvents)\n            index = open + nextEvents.length - 2\n            break\n          }\n        }\n      }\n    }\n\n    index = -1\n\n    while (++index < events.length) {\n      if (events[index][1].type === 'strikethroughSequenceTemporary') {\n        events[index][1].type = 'data'\n      }\n    }\n\n    return events\n  }\n  /** @type {Tokenizer} */\n\n  function tokenizeStrikethrough(effects, ok, nok) {\n    const previous = this.previous\n    const events = this.events\n    let size = 0\n    return start\n    /** @type {State} */\n\n    function start(code) {\n      if (\n        previous === 126 &&\n        events[events.length - 1][1].type !== 'characterEscape'\n      ) {\n        return nok(code)\n      }\n\n      effects.enter('strikethroughSequenceTemporary')\n      return more(code)\n    }\n    /** @type {State} */\n\n    function more(code) {\n      const before = classifyCharacter(previous)\n\n      if (code === 126) {\n        // If this is the third marker, exit.\n        if (size > 1) return nok(code)\n        effects.consume(code)\n        size++\n        return more\n      }\n\n      if (size < 2 && !single) return nok(code)\n      const token = effects.exit('strikethroughSequenceTemporary')\n      const after = classifyCharacter(code)\n      token._open = !after || (after === 2 && Boolean(before))\n      token._close = !before || (before === 2 && Boolean(after))\n      return ok(code)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}