{"ast":null,"code":"/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Invoked when a node (matching test, if given) is found.\n * Visitors are free to transform node.\n * They can also transform the parent of node (the last of ancestors).\n * Replacing node itself, if `SKIP` is not returned, still causes its descendants to be visited.\n * If adding or removing previous siblings (or next siblings, in case of reverse) of node,\n * visitor should return a new index (number) to specify the sibling to traverse after node is traversed.\n * Adding or removing next siblings of node (or previous siblings, in case of reverse)\n * is handled as expected without needing to return a new index.\n * Removing the children property of an ancestor still results in them being traversed.\n *\n * @template {Node} V\n * @callback Visitor\n * @param {V} node Found node\n * @param {number|null} index Position of `node` in `parent`\n * @param {Parent|null} parent Parent of `node`\n * @returns {VisitorResult}\n */\n\nimport { visitParents, CONTINUE, SKIP, EXIT } from 'unist-util-visit-parents';\nexport { CONTINUE, SKIP, EXIT };\nexport const visit =\n/**\n * @type {(\n *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &\n *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &\n *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)\n * )}\n */\n\n/**\n * Visit children of tree which pass a test\n *\n * @param {Node} tree Abstract syntax tree to walk\n * @param {Test} test test Test node\n * @param {Visitor<Node>} visitor Function to run for each node\n * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    visitor = test;\n    test = null;\n  }\n  visitParents(tree, test, overload, reverse);\n\n  /**\n   * @param {Node} node\n   * @param {Array.<Parent>} parents\n   */\n  function overload(node, parents) {\n    var parent = parents[parents.length - 1];\n    return visitor(node, parent ? parent.children.indexOf(node) : null, parent);\n  }\n};","map":{"version":3,"names":["visitParents","CONTINUE","SKIP","EXIT","visit","tree","test","visitor","reverse","overload","node","parents","parent","length","children","indexOf"],"sources":["/Users/philippknestel/Documents/GitHub/portfolio/portfolio-phkn/node_modules/mdast-util-definitions/node_modules/unist-util-visit/index.js"],"sourcesContent":["/**\n * @typedef {import('unist').Node} Node\n * @typedef {import('unist').Parent} Parent\n * @typedef {import('unist-util-is').Test} Test\n * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult\n */\n\n/**\n * Invoked when a node (matching test, if given) is found.\n * Visitors are free to transform node.\n * They can also transform the parent of node (the last of ancestors).\n * Replacing node itself, if `SKIP` is not returned, still causes its descendants to be visited.\n * If adding or removing previous siblings (or next siblings, in case of reverse) of node,\n * visitor should return a new index (number) to specify the sibling to traverse after node is traversed.\n * Adding or removing next siblings of node (or previous siblings, in case of reverse)\n * is handled as expected without needing to return a new index.\n * Removing the children property of an ancestor still results in them being traversed.\n *\n * @template {Node} V\n * @callback Visitor\n * @param {V} node Found node\n * @param {number|null} index Position of `node` in `parent`\n * @param {Parent|null} parent Parent of `node`\n * @returns {VisitorResult}\n */\n\nimport {visitParents, CONTINUE, SKIP, EXIT} from 'unist-util-visit-parents'\n\nexport {CONTINUE, SKIP, EXIT}\n\nexport const visit =\n  /**\n   * @type {(\n   *   (<T extends Node>(tree: Node, test: T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|import('unist-util-is').TestFunctionPredicate<T>>, visitor: Visitor<T>, reverse?: boolean) => void) &\n   *   ((tree: Node, test: Test, visitor: Visitor<Node>, reverse?: boolean) => void) &\n   *   ((tree: Node, visitor: Visitor<Node>, reverse?: boolean) => void)\n   * )}\n   */\n  (\n    /**\n     * Visit children of tree which pass a test\n     *\n     * @param {Node} tree Abstract syntax tree to walk\n     * @param {Test} test test Test node\n     * @param {Visitor<Node>} visitor Function to run for each node\n     * @param {boolean} [reverse] Fisit the tree in reverse, defaults to false\n     */\n    function (tree, test, visitor, reverse) {\n      if (typeof test === 'function' && typeof visitor !== 'function') {\n        reverse = visitor\n        visitor = test\n        test = null\n      }\n\n      visitParents(tree, test, overload, reverse)\n\n      /**\n       * @param {Node} node\n       * @param {Array.<Parent>} parents\n       */\n      function overload(node, parents) {\n        var parent = parents[parents.length - 1]\n        return visitor(\n          node,\n          parent ? parent.children.indexOf(node) : null,\n          parent\n        )\n      }\n    }\n  )\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAQA,YAAY,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,QAAO,0BAA0B;AAE3E,SAAQF,QAAQ,EAAEC,IAAI,EAAEC,IAAI;AAE5B,OAAO,MAAMC,KAAK;AAChB;AACF;AACA;AACA;AACA;AACA;AACA;;AAEI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACI,SAAAA,CAAUC,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,OAAO,EAAE;EACtC,IAAI,OAAOF,IAAI,KAAK,UAAU,IAAI,OAAOC,OAAO,KAAK,UAAU,EAAE;IAC/DC,OAAO,GAAGD,OAAO;IACjBA,OAAO,GAAGD,IAAI;IACdA,IAAI,GAAG,IAAI;EACb;EAEAN,YAAY,CAACK,IAAI,EAAEC,IAAI,EAAEG,QAAQ,EAAED,OAAO,CAAC;;EAE3C;AACN;AACA;AACA;EACM,SAASC,QAAQA,CAACC,IAAI,EAAEC,OAAO,EAAE;IAC/B,IAAIC,MAAM,GAAGD,OAAO,CAACA,OAAO,CAACE,MAAM,GAAG,CAAC,CAAC;IACxC,OAAON,OAAO,CACZG,IAAI,EACJE,MAAM,GAAGA,MAAM,CAACE,QAAQ,CAACC,OAAO,CAACL,IAAI,CAAC,GAAG,IAAI,EAC7CE,MACF,CAAC;EACH;AACF,CACD","ignoreList":[]},"metadata":{},"sourceType":"module"}